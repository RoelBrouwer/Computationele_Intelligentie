\documentclass[]{report}
\usepackage[margin=1.0in]{geometry}


% Title Page
\title{Practicumverslag Computationele Intelligentie}
\author{Cornelis Bouter (studentnummer) en Roel Brouwer (3976866)}
\date{27 juni 2014}

% Code Snippet settings
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{
  frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=4
}

\begin{document}
\maketitle

\chapter{Implementatie algoritmen}
\section{Hill-climbing}
\subsection{Algemeen}
\subsubsection{Representatie en bepalen begintoestand}
Sudoku's zijn gerepresenteerd als een dubbel array ($n \times n$)  van cijfers (1 t/m $n$). Probleemtoestanden zijn volledig ingevulde sudoku's, wat betekent dat er nog iets met de input moet gebeuren om een begintoestand te verkrijgen.

De lege vakjes in de sudoku worden gevuld door een willekeurig getal dat nog niet in het $n \times n$ blok voorkomt. Welk getal in het vakje terecht komt wordt bepaald door de volgende functie:

\begin{minipage}{\textwidth}
\begin{lstlisting}
ZoekVulling(AlGevuld)
	// AlGevuld is een boolean array, met voor elk getal dat
	// in een n bij n blok moet voorkomen een positie.
	// AantalOngevuld is een variabele waarin het aantal nog
	// ongevulde vakjes is opgeslagen.
	TeVullen = (int)(randomFloat(0, 1) * AantalOngevuld);
	count = 0;
	// Tot is exclusief.
	for i = 0 tot n
		if (!AlGevuld[i])
			if(count == TeVullen)
				return i + 1;
			else 
				j++;
\end{lstlisting}
\end{minipage}

Het resultaat is een volledig gevulde begintoestand.

\subsubsection{Evaluatie}
Het is nodig om toestanden te beoordelen, zodat ze vergeleken kunnen worden en we daadwerkelijk kunnen klimmen.

De onderstaande evaluatiefunctie doet dat door het aantal missende cijfers in alle rijen en kolommen bij elkaar op te tellen:

\begin{minipage}{\textwidth}
\begin{lstlisting}
Evalueer (Sudoku)
	TeReturnen = 0;
	contains = boolean[n * n];
	// Telt alle ontbrekende cijfers in de rijen op.
	for i = 0 tot n * n
		for k = 0 tot n * n 
			contains[k] = false;
		for j = 0 tot n * n
			contains[Sudoku[i][j] - 1] = true;
		for k = 0 tot n * n
			if(!contains[k]) 
				TeReturnen++;
	// Telt alle ontbrekende cijfers in de kolommen op.
	for i = 0 tot n * n
		for k = 0 tot n * n
			contains[k] = false;
		for j = 0 tot n * n
			contains[Sudoku[j][i] - 1] = true;
		for k = 0 tot n * n
			if(!contains[k]) 
				TeReturnen++;
	return TeReturnen;
\end{lstlisting}
\end{minipage}

\subsubsection{Zoekoperator}
Het bepalen van de volgende toestand in het \textit{hill-climbing} gebeurt aan de hand van de zoekoperator (hieronder in pseudo-code uitgewerkt). Deze geeft een nieuwe sudoku terug, die van de oude verschilt op twee vakjes: de eerste verwisseling die een verbetering opleverde in de evaluatiewaarde van de sudoku.

\begin{minipage}{\textwidth}
\begin{lstlisting}
ZoekOperator (Sudoku)
	// eval bevat de waarde die de evaluatiefunctie aan de sudoku geeft.
	eval = Sudoku.evalueer();
	// Verwisselen gaat per nxn-blok. g en h representeren het blok.
	// Het zijn constantes die bij de variabelen die de positie van
	// de vakjes binnen het blok representeren (i, j, k en l) worden
	// opgeteld om het juiste vakje te kunnen identificeren.
	// Tot is exclusief. In de volgende geneste loops worden alle
	// wissel-mogelijkheden afgelopen tot er een gevonden is die de
	// huidige toestand verbetert.
	for g = 0 tot n*n (ophogen per 3) 
		for h = 0 tot n*n (ophogen per 3)
			for i = 0 tot n 
				for j = 0 tot n
					for k = 0 tot n
						for l = 0 tot n
							if ((i,j) en (k,l) representeren niet hetzelfde vakje EN
							    (i,j) en (k,l) zijn variabele vakjes)
								// Verkrijg de nieuwe sudoku door de vakjes te verwisselen.
								Nieuw = Sudoku.verwissel(g + i, h + j, g + k, h + l)
								// Als de nieuwe beter is zijn we klaar.
								if (Nieuw.evalueer() > eval) 
									return Nieuw;
	// Als er niks verwisseld kan worden, zitten we in een lokaal
	// optimum. We geven de oorspronkelijke sudoku terug.
	return Sudoku;
\end{lstlisting}
\end{minipage}

Een lokaal optimum (of plateau) is gevonden op het moment dat de zoekoperator de sudoku onveranderd teruggeeft: alle successor-toestanden zijn dan immers slechter dan of even goed als de huidige toestand.

\subsection{Random Restart}
Met het klaarstaan van de zoekoperator die in de vorige sectie besproken is, is het implementeren van \textit{random restart} relatief eenvoudig. In pseudo-code ziet dat er als volgt uit:

\begin{minipage}{\textwidth}
\begin{lstlisting}
RandomRestart (HuidigeSudoku, Input)
	// Input is de originele input waaruit de begintoestand gehaald is.
	// Totdat een globaal optimum is gevonden, blijven we zoeken.
	while (Evalueer(HuidigeSudoku) > 0)
		NieuweSudoku = ZoekOperator(HuidigeSudoku);
		// Als een lokaal optimum wordt bereikt, herstarten.
		if (HuidigeSudoku == NieuweSudoku)
			// Maak een nieuwe begintoestand en begin opnieuw.
			HuidigeSudoku = Sudoku(n, Input);
		else
			// Anders gaan we door met de gevonden toestand. 
			HuidigeSudoku = NieuweSudoku;
	// Een globaal optimum is gevonden.
	Print(HuidigeSudoku);
\end{lstlisting}
\end{minipage}

\subsection{Iterated Local Search}
\subsubsection{Zoekoperator}
Voor het implementeren van \textit{iterated local search} is het nodig geweest de zoekoperator iets aan te passen, of beter gezegd: een variant op de zoekfunctie toe te voegen. 

De zoekoperator die voor het beklimmen van de heuvel, het \textit{hill-climbing} deel, gebruikt wordt, loopt alle swap-mogelijkheden in een bepaalde volgorde door, en kiest de eerste die een verbetering is. Voor \textit{iterated local search} is een \textit{random walk} nodig. Een \textit{random walk} geeft niets om het antwoord op de vraag of een opvolger-toestand al dan niet een verbetering is. Het moet een willekeurige opvolger-toestand kunnen kiezen, ongeacht de waarde die de evaluatiefunctie aan die toestand geeft. 

Wanneer de oude implementatie gebruikt zou worden, zou het dan steeds voor de eerste optie kiezen: het swappen van de eerste twee niet-vaste vakjes in het blok in de linksbovenhoek van de sudoku. Dat willen we niet, daarom veranderen we de zoekoperator-functie zodat deze twee willekeurige vakjes (binnen hetzelfde blok - natuurlijk) van plaats verwisseld worden:

\begin{minipage}{\textwidth}
\begin{lstlisting}
RandomZoekOperator (Sudoku)
	// g en h representeren het blok waarin het verwisselen wordt uitgevoerd.
	g, h = randomInt(0, n) * n;
	// i, j, k en l representeren de twee vakjes die verwisseld worden.
	i, j, k, l = randomInt(0, n);
	while ((i,j) en (k,l) representeren hetzelfde vakje OF
	  (i,j) of (k,l) is een vast vakje)
		// Nieuwe waardes voor i, j, k en l.
		i, j, k, l = randomInt(0, n);
	// Verwissel de genoemde vakjes in de sudoku en return het resultaat
	return Sudoku.verwissel(g + i, h + j, g + k, h + l);
\end{lstlisting}
\end{minipage}

\subsubsection{Zoek algoritme}
Gebruik makend van de hierboven beschreven zoekoperator(s) (zowel de willekeurige als de deterministische versie), is de implementatie van \textit{iterated local search} als volgt:

\begin{minipage}{\textwidth}
\begin{lstlisting}
IteratedLocalSearch (HuidigeSudoku)
	// Totdat een globaal optimum is gevonden, blijven we zoeken.
	while (Evalueer(HuidigeSudoku) > 0)
		NieuweSudoku = ZoekOperator(HuidigeSudoku);
		// Als een lokaal optimum wordt bereikt, daar weglopen.
		if(HuidigeSudoku == NieuweSudoku)
			// Maak een random walk van S lang, S kan gevarieerd worden.
			for i = 0 tot S
				HuidigeSudoku = RandomZoekOperator(HuidigeSudoku);
		else 
			// Anders gaan we door met de gevonden toestand.
			HuidigeSudoku = NieuweSudoku;
	// Een globaal optimum is gevonden.
	Print(HuidigeSudoku);
\end{lstlisting}
\end{minipage}

\section{Constraint Satisfaction}
\subsection{Backtracking}
\subsection{Forward Checking}

\chapter{Experimentele resultaten}
\section{Hill-climbing}
\subsection{Algemene observaties}
\subsubsection{Effici\"{e}ntie}
(Rekentijd en aantal toestanden tot lokaal optimum)
\subsubsection{Accepteren gelijke toestanden}
\subsection{Random Restart}
\subsubsection{Effici\"{e}ntie}
(Rekentijd en aantal toestanden tot globaal optimum)
\subsection{Iterated Local Search}
\subsubsection{Effici\"{e}ntie}
(Rekentijd en aantal toestanden tot globaal optimum)
\section{Constraint Satisfaction}
\subsection{Backtracking}
\subsection{Forward Checking}

\end{document}          
